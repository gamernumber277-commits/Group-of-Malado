package test.lakers.pkg3d;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.util.List;
import java.net.URL;

public class Lakers extends JFrame implements KeyListener, ActionListener {

    // Game Constants and State
    private int p, p1; // Player X, Y
    private final int playerSize = 30;
    private int currentPlayerSpeed = 5;
    private final int NORMAL_SPEED = 5;
    private final int SLOW_SPEED = 1;
    
    private Image playerImage, enemyImage;
    private int ex, ey; // Enemy X, Y
    private final int enemySize = 30;
    private int enemySpeed = 3;

    private boolean l, r, u, d;
    private boolean won = false;
    private boolean gameOver = false;
    private boolean isSlowed = false;

    // --- NEW HEALTH STATE ---
    private int lives = 3; 
    // ------------------------

    private int level = 1;
    private int score = 0;
    private final int TILE = 40;

    // Maze Layouts
    private final int[][][] MAZE_LEVELS = {
        {
            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
            {1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
            {1,0,1,0,1,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1},
            {1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,1},
            {1,1,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1},
            {1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1},
            {1,1,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,0,1,1,0,0,1},
            {1,0,1,0,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,1},
            {1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,1,0,0,1,0,1,1,0,1,0,1,0,1,0,1},
            {1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,1,0,0,1,0,1,0,1,0,1},
            {1,1,0,1,1,0,1,1,1,0,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1},
            {1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,1},
            {1,0,1,1,0,1,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,0,0,1,1,0,1,0,1},
            {1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,0,1,0,1,0,0,1,0,1,0,1,1,1,0,0,1,0,1},
            {1,1,0,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,0,0,0,1,1,0,1},
            {1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1},
            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
        },
        {
            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
            {1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1},
            {1,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1},
            {1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,0,0,1,0,1,1,1,0,1,0,1,1,1,0,0,1},
            {1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
            {1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,0,1,1,0,1,1,1,1,1,0,1,1,1,0,0,0,1,1,1},
            {1,0,0,0,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
            {1,0,1,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1},
            {1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1,0,1},
            {1,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,0,1},
            {1,0,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0,1},
            {1,0,1,0,1,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,0,1},
            {1,0,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,1,0,0,0,1},
            {1,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,0,1,0,1},
            {1,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,1,1},
            {1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
            {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}
        }
    };

    private int[][] currentMaze = MAZE_LEVELS[0];

    class Question {
        String q;
        List<String> options;
        String correctVal;
        Question(String q, String[] opt, int ans) { 
            this.q = q; 
            this.options = new ArrayList<String>();
            for(String s : opt) this.options.add(s);
            this.correctVal = opt[ans];
        }
        void shuffle() { Collections.shuffle(options); }
        int getCorrectIdx() { return options.indexOf(correctVal); }
    }

    private List<Question> questionBank = new ArrayList<Question>();
    private Question currentQuestion;
    private final List<AnswerOrb> activeOrbs = new ArrayList<AnswerOrb>();
    
    class AnswerOrb {
        Rectangle rect;
        int optIdx;
        char label; 
        AnswerOrb(Rectangle r, int idx, char l) { this.rect = r; this.optIdx = idx; this.label = l; }
    }

    private final List<Rectangle> mazeWalls = new ArrayList<Rectangle>();
    private final Random random = new Random();
    private final JPanel gamePanel;
    private final javax.swing.Timer gameLoop;

    public Lakers() {
        setTitle("Science Quiz Maze");
        setSize(MAZE_LEVELS[0][0].length * TILE + 16, MAZE_LEVELS[0].length * TILE + 160);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        setLocationRelativeTo(null);

        initQuestions();
        loadImages();
        nextQuestion();
        loadLevel();

        gamePanel = new JPanel() {
            @Override
            protected void paintComponent(Graphics g) {
                super.paintComponent(g);
                drawMaze(g);
                drawOrbs(g);
                drawEnemy(g);
                drawPlayer(g);
                drawUI(g);

                if (gameOver) {
                    g.setColor(new Color(0,0,0,200));
                    g.fillRect(0,0,getWidth(),getHeight());
                    g.setColor(Color.RED);
                    g.setFont(new Font("Arial", Font.BOLD, 70));
                    g.drawString("GAME OVER", getWidth()/2 - 200, getHeight()/2);
                }
                if (won) {
                    g.setColor(new Color(0,0,0,180));
                    g.fillRect(0,0,getWidth(),getHeight());
                    g.setColor(Color.GREEN);
                    g.setFont(new Font("Arial", Font.BOLD, 70));
                    g.drawString("ULTIMATE WINNER!", getWidth()/2 - 300, getHeight()/2);
                }
            }
        };

        gamePanel.setFocusable(true);
        gamePanel.addKeyListener(this);
        gamePanel.setBackground(Color.DARK_GRAY);
        
        add(gamePanel);
        gameLoop = new javax.swing.Timer(16, this);
        gameLoop.start();
        setVisible(true);
    }

    private void initQuestions() {
        questionBank.add(new Question("Powerhouse of the cell?", new String[]{"Nucleus", "Ribosome", "Mitochondria", "Wall"}, 2));
        questionBank.add(new Question("Center of an atom?", new String[]{"Electron", "Proton", "Nucleus", "Orbit"}, 2));
        questionBank.add(new Question("Gas plants absorb?", new String[]{"Oxygen", "Nitrogen", "Hydrogen", "CO2"}, 3));
        questionBank.add(new Question("The Red Planet?", new String[]{"Mars", "Venus", "Jupiter", "Saturn"}, 0));
        questionBank.add(new Question("Boiling point of water?", new String[]{"50C", "100C", "150C", "200C"}, 1));
        questionBank.add(new Question("Study of living things?", new String[]{"Physics", "Biology", "Geology", "Math"}, 1));
        questionBank.add(new Question("Hardest natural substance?", new String[]{"Gold", "Steel", "Diamond", "Iron"}, 2));
        questionBank.add(new Question("What do bees collect?", new String[]{"Nectar", "Soil", "Wood", "Water"}, 0));
        questionBank.add(new Question("Symbol for Gold?", new String[]{"Go", "Gd", "Ag", "Au"}, 3));
        questionBank.add(new Question("Nearest star to Earth?", new String[]{"Sirius", "Alpha Centauri", "The Sun", "Vega"}, 2));
    }

    private void nextQuestion() {
        currentQuestion = questionBank.get(random.nextInt(questionBank.size()));
        currentQuestion.shuffle();
    }

    private void loadLevel() {
        mazeWalls.clear();
        for (int r = 0; r < currentMaze.length; r++) {
            for (int c = 0; c < currentMaze[r].length; c++) {
                if (currentMaze[r][c] == 1) mazeWalls.add(new Rectangle(c * TILE, r * TILE, TILE, TILE));
            }
        }
        randomizePositions();
    }

    private void randomizePositions() {
        List<Point> free = new ArrayList<Point>();
        for (int r = 0; r < currentMaze.length; r++) {
            for (int c = 0; c < currentMaze[r].length; c++) {
                if (currentMaze[r][c] == 0) free.add(new Point(c, r));
            }
        }
        if(free.size() < 6) return; 

        Point pS = free.remove(random.nextInt(free.size()));
        p = pS.x * TILE + 5; p1 = pS.y * TILE + 5;

        Point eS = free.remove(random.nextInt(free.size()));
        ex = eS.x * TILE; ey = eS.y * TILE;

        activeOrbs.clear();
        char[] labels = {'A', 'B', 'C', 'D'};
        List<Integer> opts = new ArrayList<Integer>();
        for (int i = 0; i < 4; i++) opts.add(i);
        Collections.shuffle(opts);

        for (int i = 0; i < 4; i++) {
            Point oP = free.remove(random.nextInt(free.size()));
            int idx = opts.get(i);
            activeOrbs.add(new AnswerOrb(new Rectangle(oP.x * TILE + 10, oP.y * TILE + 10, 20, 20), idx, labels[idx]));
        }
    }

    private void drawUI(Graphics g) {
        g.setColor(Color.WHITE);
        g.setFont(new Font("Arial", Font.BOLD, 18));
        g.drawString("Level: " + level + "  Score: " + score, 20, 30);
        
        // --- DRAW HEARTS ---
        g.setColor(Color.RED);
        String heartSymbol = "â¤";
        String displayLives = "";
        for(int i=0; i<lives; i++) displayLives += heartSymbol + " ";
        g.setFont(new Font("Arial", Font.BOLD, 25));
        g.drawString(displayLives, 20, 65);
        // -------------------

        g.setColor(new Color(50, 50, 50));
        g.fillRect(200, 5, 900, 60);
        g.setColor(Color.YELLOW);
        g.setFont(new Font("Arial", Font.BOLD, 18));
        g.drawString("QUESTION: " + currentQuestion.q, 220, 25);
        
        g.setFont(new Font("Arial", Font.PLAIN, 14));
        String opts = "A) " + currentQuestion.options.get(0) + "  B) " + currentQuestion.options.get(1) + 
                      "  C) " + currentQuestion.options.get(2) + "  D) " + currentQuestion.options.get(3);
        g.drawString(opts, 220, 50);

        if (isSlowed) {
            g.setColor(Color.RED);
            g.drawString("WRONG! -1 LIFE & SLOWED!", 220, 75);
        }
    }

    private void drawOrbs(Graphics g) {
        for (AnswerOrb orb : activeOrbs) {
            g.setColor(Color.CYAN);
            g.fillOval(orb.rect.x, orb.rect.y, orb.rect.width, orb.rect.height);
            g.setColor(Color.BLACK);
            g.setFont(new Font("Arial", Font.BOLD, 12));
            g.drawString(String.valueOf(orb.label), orb.rect.x + 6, orb.rect.y + 15);
        }
    }

    private void drawMaze(Graphics g) {
        g.setColor(Color.BLACK);
        for (Rectangle wall : mazeWalls) g.fillRect(wall.x, wall.y, wall.width, wall.height);
    }

    private void drawPlayer(Graphics g) {
        if (playerImage != null) g.drawImage(playerImage, p, p1, playerSize, playerSize, null);
        else { g.setColor(Color.BLUE); g.fillRect(p, p1, playerSize, playerSize); }
    }

    private void drawEnemy(Graphics g) {
        if (enemyImage != null) g.drawImage(enemyImage, ex, ey, enemySize, enemySize, null);
        else { g.setColor(Color.RED); g.fillOval(ex, ey, enemySize, enemySize); }
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        if (!won && !gameOver) {
            movePlayer();
            moveEnemy();
            checkCollisions();
        }
        gamePanel.repaint();
    }

    private void movePlayer() {
        int nx = p, ny = p1;
        if (l) nx -= currentPlayerSpeed;
        if (r) nx += currentPlayerSpeed;
        if (u) ny -= currentPlayerSpeed;
        if (d) ny += currentPlayerSpeed;

        if (!collides(new Rectangle(nx, p1, playerSize, playerSize))) p = nx;
        if (!collides(new Rectangle(p, ny, playerSize, playerSize))) p1 = ny;
    }

    private boolean collides(Rectangle r) {
        for(Rectangle wall : mazeWalls) {
            if(r.intersects(wall)) return true;
        }
        return false;
    }

    private void checkCollisions() {
        Rectangle pRect = new Rectangle(p, p1, playerSize, playerSize);
        
        // Enemy Hit
        if (pRect.intersects(new Rectangle(ex, ey, enemySize, enemySize))) {
            lives = 0; // Instant death or you could do lives--
            triggerGameOver();
        }

        // Orb Hit
        for (int i = 0; i < activeOrbs.size(); i++) {
            AnswerOrb orb = activeOrbs.get(i);
            if (pRect.intersects(orb.rect)) {
                if (orb.optIdx == currentQuestion.getCorrectIdx()) {
                    score += 50;
                    checkProgress();
                } else {
                    // --- MINUS LIFE LOGIC ---
                    lives--;
                    if(lives <= 0) {
                        triggerGameOver();
                    } else {
                        applySlowness();
                    }
                    // ------------------------
                }
                nextQuestion();
                randomizePositions();
                break;
            }
        }
    }

    private void triggerGameOver() {
        gameOver = true;
        gameLoop.stop();
    }

    private void checkProgress() {
        if (level == 1 && score >= 200) {
            level = 2;
            enemySpeed = 4;
            currentMaze = MAZE_LEVELS[1];
            loadLevel();
            JOptionPane.showMessageDialog(this, "Level 1 Clear! Level 2 Start.");
        } else if (level == 2 && score >= 400) {
            won = true;
            gameLoop.stop();
        }
    }

    private void applySlowness() {
        if (isSlowed) return;
        isSlowed = true;
        currentPlayerSpeed = SLOW_SPEED;
        javax.swing.Timer st = new javax.swing.Timer(3000, new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                currentPlayerSpeed = NORMAL_SPEED;
                isSlowed = false;
            }
        });
        st.setRepeats(false);
        st.start();
    }

    // --- SMART BFS AI ---
    private void moveEnemy() {
        Point start = new Point(ex / TILE, ey / TILE);
        Point target = new Point(p / TILE, p1 / TILE);
        List<Point> path = findPath(start, target);

        if (path != null && path.size() > 1) {
            Point nextStep = path.get(1);
            int targetX = nextStep.x * TILE;
            int targetY = nextStep.y * TILE;
            int s = enemySpeed - 1;

            if (ex < targetX) ex += Math.min(s, targetX - ex);
            else if (ex > targetX) ex -= Math.min(s, ex - targetX);
            if (ey < targetY) ey += Math.min(s, targetY - ey);
            else if (ey > targetY) ey -= Math.min(s, ey - targetY);
        }
    }

    private List<Point> findPath(Point start, Point target) {
        if (start.equals(target)) return null;
        Queue<List<Point>> queue = new LinkedList<List<Point>>();
        Set<Point> visited = new HashSet<Point>();
        List<Point> startPath = new ArrayList<Point>();
        startPath.add(start);
        queue.add(startPath);
        visited.add(start);

        while (!queue.isEmpty()) {
            List<Point> currentPath = queue.poll();
            Point lastNode = currentPath.get(currentPath.size() - 1);
            if (lastNode.equals(target)) return currentPath;

            int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
            for (int[] d : dirs) {
                Point neighbor = new Point(lastNode.x + d[0], lastNode.y + d[1]);
                if (neighbor.y >= 0 && neighbor.y < currentMaze.length && 
                    neighbor.x >= 0 && neighbor.x < currentMaze[0].length &&
                    currentMaze[neighbor.y][neighbor.x] == 0 && !visited.contains(neighbor)) {
                    visited.add(neighbor);
                    List<Point> newPath = new ArrayList<Point>(currentPath);
                    newPath.add(neighbor);
                    queue.add(newPath);
                }
            }
        }
        return null; 
    }

    private void loadImages() {
        try {
            URL pUrl = getClass().getResource("lala (1).png");
            if (pUrl != null) playerImage = new ImageIcon(pUrl).getImage();
            URL eUrl = getClass().getResource("wega.jpg");
            if (eUrl != null) enemyImage = new ImageIcon(eUrl).getImage();
        } catch (Exception e) { System.out.println("Images missing"); }
    }

    @Override public void keyPressed(KeyEvent e) { setKey(e.getKeyCode(), true); }
    @Override public void keyReleased(KeyEvent e) { setKey(e.getKeyCode(), false); }
    @Override public void keyTyped(KeyEvent e) {}

    private void setKey(int k, boolean pr) {
        if (k == KeyEvent.VK_A || k == KeyEvent.VK_LEFT) l = pr;
        if (k == KeyEvent.VK_D || k == KeyEvent.VK_RIGHT) r = pr;
        if (k == KeyEvent.VK_W || k == KeyEvent.VK_UP) u = pr;
        if (k == KeyEvent.VK_S || k == KeyEvent.VK_DOWN) d = pr;
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(new Runnable() {
            @Override public void run() { new Lakers(); }
        });
    }
}
